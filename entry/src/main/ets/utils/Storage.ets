import preferences from '@ohos.data.preferences';
import common from '@ohos.app.ability.common';
import { HealthData, DailyHealthRecord, StatisticsData, NoteItem, HealthScore, HealthAnalysis, Template, ThemePreset } from './Types'; // å¯¼å…¥å…±äº«æ¥å£
import { HealthCalculator } from './HealthCalculator';

class StorageManager {
  private static instance: StorageManager;
  private pref: preferences.Preferences | null = null;

  private constructor() {}

  /**
   * è·å–å•ä¾‹å®ä¾‹
   */
  public static getInstance(): StorageManager {
    if (!StorageManager.instance) {
      StorageManager.instance = new StorageManager();
    }
    return StorageManager.instance;
  }

  /**
   * åˆå§‹åŒ–é¦–é€‰é¡¹
   * @param context åº”ç”¨ä¸Šä¸‹æ–‡
   */
  public async init(context: common.UIAbilityContext): Promise<void> {
    if (!this.pref) {
      try {
        this.pref = await preferences.getPreferences(context, 'noteApp');
        console.log('é¦–é€‰é¡¹åˆå§‹åŒ–æˆåŠŸ');
      } catch (error) {
        console.error(`é¦–é€‰é¡¹åˆå§‹åŒ–å¤±è´¥: ${error}`);
        throw new Error(error);
      }
    }
  }

  /**
   * ä¿å­˜å†å²ç¬”è®°
   * @param notes å†å²ç¬”è®°æ•°ç»„
   */
  public async saveHistoryNotes(notes: string[]): Promise<void> {
    if (!this.pref) {
      throw new Error('é¦–é€‰é¡¹æœªåˆå§‹åŒ–');
    }
    try {
      await this.pref.put('historyNotes', JSON.stringify(notes));
      await this.pref.flush();
      console.log('å†å²ç¬”è®°ä¿å­˜æˆåŠŸ');
    } catch (error) {
      console.error(`å†å²ç¬”è®°ä¿å­˜å¤±è´¥: ${error}`);
      throw new Error(error);
    }
  }

  /**
   * è·å–å†å²ç¬”è®°
   * @returns å†å²ç¬”è®°æ•°ç»„
   */
  public async getHistoryNotes(): Promise<string[]> {
    if (!this.pref) {
      throw new Error('é¦–é€‰é¡¹æœªåˆå§‹åŒ–');
    }
    try {
      const notesStr = await this.pref.get('historyNotes', '[]');
      return JSON.parse(notesStr as string) as string[];
    } catch (error) {
      console.error(`å†å²ç¬”è®°è·å–å¤±è´¥: ${error}`);
      return [];
    }
  }

  /**
   * ä¿å­˜å½“å‰ç¬”è®°
   * @param note å½“å‰ç¬”è®°å†…å®¹
   */
  public async saveCurrentNote(note: string): Promise<void> {
    if (!this.pref) {
      throw new Error('é¦–é€‰é¡¹æœªåˆå§‹åŒ–');
    }
    try {
      await this.pref.put('currentNote', note);
      await this.pref.flush();
      console.log('å½“å‰ç¬”è®°ä¿å­˜æˆåŠŸ');
    } catch (error) {
      console.error(`å½“å‰ç¬”è®°ä¿å­˜å¤±è´¥: ${error}`);
      throw new Error(error);
    }
  }

  /**
   * è·å–å½“å‰ç¬”è®°
   * @returns å½“å‰ç¬”è®°å†…å®¹
   */
  public async getCurrentNote(): Promise<string> {
    if (!this.pref) {
      throw new Error('é¦–é€‰é¡¹æœªåˆå§‹åŒ–');
    }
    try {
      return await this.pref.get('currentNote', '') as string;
    } catch (error) {
      console.error(`å½“å‰ç¬”è®°è·å–å¤±è´¥: ${error}`);
      return '';
    }
  }

  /**
   * ä¿å­˜è‡ªå®šä¹‰æ¨¡æ¿
   * @param templates è‡ªå®šä¹‰æ¨¡æ¿æ•°ç»„
   */
  public async saveCustomTemplates(templates: Template[]): Promise<void> {
    if (!this.pref) {
      throw new Error('é¦–é€‰é¡¹æœªåˆå§‹åŒ–');
    }
    try {
      await this.pref.put('customTemplates', JSON.stringify(templates));
      await this.pref.flush();
      console.log('è‡ªå®šä¹‰æ¨¡æ¿ä¿å­˜æˆåŠŸ');
    } catch (error) {
      console.error(`è‡ªå®šä¹‰æ¨¡æ¿ä¿å­˜å¤±è´¥: ${error}`);
      throw new Error(error);
    }
  }

  /**
   * è·å–è‡ªå®šä¹‰æ¨¡æ¿
   * @returns è‡ªå®šä¹‰æ¨¡æ¿æ•°ç»„
   */
  public async getCustomTemplates(): Promise<Template[]> {
    if (!this.pref) {
      throw new Error('é¦–é€‰é¡¹æœªåˆå§‹åŒ–');
    }
    try {
      const templatesStr = await this.pref.get('customTemplates', '[]');
      const parsed: string[] | Template[] = JSON.parse(templatesStr as string) as string[] | Template[];
      // å…¼å®¹æ—§æ ¼å¼ï¼šå¦‚æœæ˜¯string[]ï¼Œè½¬æ¢ä¸ºTemplate[]
      if (Array.isArray(parsed) && parsed.length > 0 && typeof parsed[0] === 'string') {
        const stringTemplates = parsed as string[];
        return stringTemplates.map((content: string, index: number): Template => {
          const template: Template = {
            id: `custom_${index}`,
            name: `è‡ªå®šä¹‰æ¨¡æ¿${index + 1}`,
            icon: 'ğŸ“„',
            content: content,
            category: 'è‡ªå®šä¹‰'
          };
          return template;
        });
      }
      return parsed as Template[];
    } catch (error) {
      console.error(`è‡ªå®šä¹‰æ¨¡æ¿è·å–å¤±è´¥: ${error}`);
      return [];
    }
  }

  /**
   * ä¿å­˜ä¸»é¢˜åå¥½
   */
  public async saveThemePreference(themeId: string): Promise<void> {
    if (!this.pref) {
      throw new Error('é¦–é€‰é¡¹æœªåˆå§‹åŒ–');
    }
    try {
      await this.pref.put('themePreset', themeId);
      await this.pref.flush();
    } catch (error) {
      console.error(`ä¸»é¢˜åå¥½ä¿å­˜å¤±è´¥: ${error}`);
      throw new Error(error);
    }
  }

  /**
   * è¯»å–ä¸»é¢˜åå¥½
   */
  public async getThemePreference(): Promise<string> {
    if (!this.pref) {
      throw new Error('é¦–é€‰é¡¹æœªåˆå§‹åŒ–');
    }
    try {
      return await this.pref.get('themePreset', '') as string;
    } catch (error) {
      console.error(`ä¸»é¢˜åå¥½è·å–å¤±è´¥: ${error}`);
      return '';
    }
  }

  /**
   * ä¿å­˜è‡ªå®šä¹‰ä¸»é¢˜
   */
  public async saveCustomThemePreset(theme: ThemePreset): Promise<void> {
    if (!this.pref) {
      throw new Error('é¦–é€‰é¡¹æœªåˆå§‹åŒ–');
    }
    try {
      await this.pref.put('customThemePreset', JSON.stringify(theme));
      await this.pref.flush();
    } catch (error) {
      console.error(`è‡ªå®šä¹‰ä¸»é¢˜ä¿å­˜å¤±è´¥: ${error}`);
      throw new Error(error);
    }
  }

  /**
   * è¯»å–è‡ªå®šä¹‰ä¸»é¢˜
   */
  public async getCustomThemePreset(): Promise<ThemePreset | null> {
    if (!this.pref) {
      throw new Error('é¦–é€‰é¡¹æœªåˆå§‹åŒ–');
    }
    try {
      const storedTheme = await this.pref.get('customThemePreset', '');
      if (!storedTheme || (storedTheme as string).length === 0) {
        return null;
      }
      return JSON.parse(storedTheme as string) as ThemePreset;
    } catch (error) {
      console.error(`è‡ªå®šä¹‰ä¸»é¢˜è·å–å¤±è´¥: ${error}`);
      return null;
    }
  }

  // ä¿å­˜å¥åº·æ•°æ®æ–¹æ³•
  public async saveHealthData(healthData: HealthData): Promise<void> {
    if (!this.pref) {
      throw new Error('é¦–é€‰é¡¹æœªåˆå§‹åŒ–');
    }
    try {
      await this.pref.put('healthData', JSON.stringify(healthData));
      await this.pref.flush();
      console.log('å¥åº·æ•°æ®ä¿å­˜æˆåŠŸ');
    } catch (error) {
      console.error(`å¥åº·æ•°æ®ä¿å­˜å¤±è´¥: ${error}`);
      throw new Error(error);
    }
  }

  // è·å–å¥åº·æ•°æ®æ–¹æ³•
  public async getHealthData(): Promise<HealthData> {
    if (!this.pref) {
      throw new Error('é¦–é€‰é¡¹æœªåˆå§‹åŒ–');
    }
    try {
      const data = await this.pref.get('healthData', '{}');
      return JSON.parse(data as string) as HealthData;
    } catch (error) {
      console.error(`å¥åº·æ•°æ®è·å–å¤±è´¥: ${error}`);
      return { waterCount: 0, sleepHours: 7, stepsCount: 0, mood: 'å¼€å¿ƒ' };
    }
  }

  /**
   * ä¿å­˜æ¯æ—¥å¥åº·è®°å½•
   * @param record æ¯æ—¥å¥åº·è®°å½•
   */
  public async saveDailyHealthRecord(record: DailyHealthRecord): Promise<void> {
    if (!this.pref) {
      throw new Error('é¦–é€‰é¡¹æœªåˆå§‹åŒ–');
    }
    try {
      const records = await this.getDailyHealthRecords();
      // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨è¯¥æ—¥æœŸçš„è®°å½•
      const index = records.findIndex(r => r.date === record.date);
      if (index >= 0) {
        records[index] = record; // æ›´æ–°
      } else {
        records.push(record); // æ–°å¢
      }
      await this.pref.put('dailyHealthRecords', JSON.stringify(records));
      await this.pref.flush();
      console.log('æ¯æ—¥å¥åº·è®°å½•ä¿å­˜æˆåŠŸ');
    } catch (error) {
      console.error(`æ¯æ—¥å¥åº·è®°å½•ä¿å­˜å¤±è´¥: ${error}`);
      throw new Error(error);
    }
  }

  /**
   * è·å–æ‰€æœ‰æ¯æ—¥å¥åº·è®°å½•
   * @returns æ¯æ—¥å¥åº·è®°å½•æ•°ç»„
   */
  public async getDailyHealthRecords(): Promise<DailyHealthRecord[]> {
    if (!this.pref) {
      throw new Error('é¦–é€‰é¡¹æœªåˆå§‹åŒ–');
    }
    try {
      const recordsStr = await this.pref.get('dailyHealthRecords', '[]');
      return JSON.parse(recordsStr as string) as DailyHealthRecord[];
    } catch (error) {
      console.error(`æ¯æ—¥å¥åº·è®°å½•è·å–å¤±è´¥: ${error}`);
      return [];
    }
  }

  /**
   * è·å–ç»Ÿè®¡æ•°æ®
   */
  public async getStatisticsData(): Promise<StatisticsData> {
    if (!this.pref) {
      throw new Error('é¦–é€‰é¡¹æœªåˆå§‹åŒ–');
    }
    try {
      const notes = await this.getHistoryNotes();
      const records = await this.getDailyHealthRecords();
      
      // è®¡ç®—æ€»å­—æ•°
      const totalWords = notes.reduce((sum, note) => sum + note.replace(/\s/g, '').length, 0);
      
      // è®¡ç®—å¥åº·æ•°æ®å¹³å‡å€¼
      let avgWater = 0;
      let avgSleep = 0;
      let avgSteps = 0;
      const moodCount: Record<string, number> = {};
      
      if (records.length > 0) {
        avgWater = records.reduce((sum, r) => sum + r.waterCount, 0) / records.length;
        avgSleep = records.reduce((sum, r) => sum + r.sleepHours, 0) / records.length;
        avgSteps = records.reduce((sum, r) => sum + r.stepsCount, 0) / records.length;
        
        records.forEach(r => {
          moodCount[r.mood] = (moodCount[r.mood] || 0) + 1;
        });
      }
      
      // æ‰¾å‡ºæœ€å¸¸è§çš„å¿ƒæƒ…
      let mostCommonMood = 'å¼€å¿ƒ';
      let maxCount = 0;
      const moodKeys = Object.keys(moodCount);
      for (let i = 0; i < moodKeys.length; i++) {
        const mood = moodKeys[i];
        if (moodCount[mood] > maxCount) {
          maxCount = moodCount[mood];
          mostCommonMood = mood;
        }
      }
      
      return {
        totalNotes: notes.length,
        totalWords: totalWords,
        avgWaterCount: Math.round(avgWater * 10) / 10,
        avgSleepHours: Math.round(avgSleep * 10) / 10,
        avgStepsCount: Math.round(avgSteps),
        healthRecordsCount: records.length,
        mostCommonMood: mostCommonMood
      };
    } catch (error) {
      console.error(`ç»Ÿè®¡æ•°æ®è·å–å¤±è´¥: ${error}`);
      return {
        totalNotes: 0,
        totalWords: 0,
        avgWaterCount: 0,
        avgSleepHours: 0,
        avgStepsCount: 0,
        healthRecordsCount: 0,
        mostCommonMood: 'å¼€å¿ƒ'
      };
    }
  }

  /**
   * å¯¼å‡ºæ‰€æœ‰æ•°æ®ä¸ºJSONå­—ç¬¦ä¸²
   */
  public async exportAllData(): Promise<string> {
    try {
      const notes = await this.getHistoryNotes();
      const healthData = await this.getHealthData();
      const records = await this.getDailyHealthRecords();
      const templates = await this.getCustomTemplates();
      
      interface ExportData {
        exportTime: string;
        version: string;
        notes: string[];
        healthData: HealthData;
        dailyHealthRecords: DailyHealthRecord[];
        customTemplates: Template[];
      }
      
      const exportData: ExportData = {
        exportTime: new Date().toISOString(),
        version: '1.0.0',
        notes: notes,
        healthData: healthData,
        dailyHealthRecords: records,
        customTemplates: templates
      };
      
      return JSON.stringify(exportData, null, 2);
    } catch (error) {
      console.error(`æ•°æ®å¯¼å‡ºå¤±è´¥: ${error}`);
      throw new Error(error);
    }
  }

  /**
   * ç”Ÿæˆå”¯ä¸€ID
   */
  private generateNoteId(): string {
    return `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * ä¿å­˜ç¬”è®°åˆ—è¡¨ï¼ˆNoteItemæ ¼å¼ï¼‰
   */
  public async saveNoteItems(notes: NoteItem[]): Promise<void> {
    if (!this.pref) {
      throw new Error('é¦–é€‰é¡¹æœªåˆå§‹åŒ–');
    }
    try {
      await this.pref.put('noteItems', JSON.stringify(notes));
      await this.pref.flush();
      console.log('ç¬”è®°åˆ—è¡¨ä¿å­˜æˆåŠŸ');
    } catch (error) {
      console.error(`ç¬”è®°åˆ—è¡¨ä¿å­˜å¤±è´¥: ${error}`);
      throw new Error(error);
    }
  }

  /**
   * è·å–ç¬”è®°åˆ—è¡¨ï¼ˆNoteItemæ ¼å¼ï¼‰
   */
  public async getNoteItems(): Promise<NoteItem[]> {
    if (!this.pref) {
      throw new Error('é¦–é€‰é¡¹æœªåˆå§‹åŒ–');
    }
    try {
      const notesStr = await this.pref.get('noteItems', '[]');
      const notes = JSON.parse(notesStr as string) as NoteItem[];
      
      // å¦‚æœæ•°æ®æ ¼å¼æ—§ï¼Œå°è¯•è¿ç§»
      if (notes.length > 0 && !notes[0].id) {
        console.log('æ£€æµ‹åˆ°æ—§æ ¼å¼ç¬”è®°ï¼Œå¼€å§‹è¿ç§»...');
        return await this.migrateOldNotes();
      }
      
      return notes;
    } catch (error) {
      console.error(`ç¬”è®°åˆ—è¡¨è·å–å¤±è´¥: ${error}`);
      return [];
    }
  }

  /**
   * ä»æ—§æ ¼å¼è¿ç§»åˆ°æ–°æ ¼å¼
   */
  public async migrateOldNotes(): Promise<NoteItem[]> {
    try {
      const oldNotes = await this.getHistoryNotes();
      const newNotes: NoteItem[] = oldNotes.map((content, index) => {
        const now = new Date().toISOString();
        const noteItem: NoteItem = {
          id: this.generateNoteId(),
          content: content,
          category: 'æœªåˆ†ç±»',
          tags: [],
          createTime: now,
          updateTime: now
        };
        return noteItem;
      });
      
      // ä¿å­˜æ–°æ ¼å¼
      await this.saveNoteItems(newNotes);
      console.log(`æˆåŠŸè¿ç§» ${newNotes.length} æ¡ç¬”è®°`);
      
      return newNotes;
    } catch (error) {
      console.error(`ç¬”è®°è¿ç§»å¤±è´¥: ${error}`);
      return [];
    }
  }

  /**
   * æ·»åŠ æ–°ç¬”è®°
   */
  public async addNoteItem(content: string, category?: string, tags?: string[]): Promise<NoteItem> {
    const notes = await this.getNoteItems();
    const now = new Date().toISOString();
    const newNote: NoteItem = {
      id: this.generateNoteId(),
      content: content,
      category: category || 'æœªåˆ†ç±»',
      tags: tags || [],
      createTime: now,
      updateTime: now
    };
    
    notes.unshift(newNote);
    await this.saveNoteItems(notes);
    return newNote;
  }

  /**
   * æ›´æ–°ç¬”è®°
   */
  public async updateNoteItem(id: string, content: string, category?: string, tags?: string[]): Promise<boolean> {
    const notes = await this.getNoteItems();
    const index = notes.findIndex(n => n.id === id);
    
    if (index >= 0) {
      notes[index].content = content;
      notes[index].updateTime = new Date().toISOString();
      if (category !== undefined) {
        notes[index].category = category;
      }
      if (tags !== undefined) {
        notes[index].tags = tags;
      }
      await this.saveNoteItems(notes);
      return true;
    }
    return false;
  }

  /**
   * åˆ é™¤ç¬”è®°
   */
  public async deleteNoteItem(id: string): Promise<boolean> {
    const notes = await this.getNoteItems();
    const index = notes.findIndex(n => n.id === id);
    
    if (index >= 0) {
      notes.splice(index, 1);
      await this.saveNoteItems(notes);
      return true;
    }
    return false;
  }

  /**
   * è·å–æ‰€æœ‰åˆ†ç±»
   */
  public async getCategories(): Promise<string[]> {
    const notes = await this.getNoteItems();
    const categories = new Set<string>();
    notes.forEach(note => {
      if (note.category) {
        categories.add(note.category);
      }
    });
    return Array.from(categories).sort();
  }

  /**
   * è·å–æ‰€æœ‰æ ‡ç­¾
   */
  public async getAllTags(): Promise<string[]> {
    const notes = await this.getNoteItems();
    const tags = new Set<string>();
    notes.forEach(note => {
      if (note.tags && note.tags.length > 0) {
        note.tags.forEach(tag => tags.add(tag));
      }
    });
    return Array.from(tags).sort();
  }

  /**
   * æŒ‰åˆ†ç±»ç­›é€‰ç¬”è®°
   */
  public async getNotesByCategory(category: string): Promise<NoteItem[]> {
    const notes = await this.getNoteItems();
    return notes.filter(n => n.category === category);
  }

  /**
   * æŒ‰æ ‡ç­¾ç­›é€‰ç¬”è®°
   */
  public async getNotesByTag(tag: string): Promise<NoteItem[]> {
    const notes = await this.getNoteItems();
    return notes.filter(n => n.tags && n.tags.includes(tag));
  }

  /**
   * æœç´¢ç¬”è®°
   */
  public async searchNotes(keyword: string): Promise<NoteItem[]> {
    const notes = await this.getNoteItems();
    const lowerKeyword = keyword.toLowerCase();
    return notes.filter(note => 
      note.content.toLowerCase().includes(lowerKeyword) ||
      note.category?.toLowerCase().includes(lowerKeyword) ||
      note.tags?.some(tag => tag.toLowerCase().includes(lowerKeyword))
    );
  }

  /**
   * è·å–å¥åº·è¯„åˆ†
   */
  public async getHealthScore(): Promise<HealthScore> {
    const healthData = await this.getHealthData();
    const records = await this.getDailyHealthRecords();
    return HealthCalculator.calculateHealthScore(healthData, records);
  }

  /**
   * è·å–å¥åº·åˆ†æ
   */
  public async getHealthAnalysis(): Promise<HealthAnalysis> {
    const healthData = await this.getHealthData();
    const records = await this.getDailyHealthRecords();
    return HealthCalculator.calculateHealthAnalysis(healthData, records);
  }

  /**
   * æ¸…ç©ºæ‰€æœ‰æ•°æ®
   */
  public async clearAllData(): Promise<void> {
    if (!this.pref) {
      throw new Error('é¦–é€‰é¡¹æœªåˆå§‹åŒ–');
    }
    try {
      await this.pref.clear();
      await this.pref.flush();
      console.log('æ‰€æœ‰æ•°æ®å·²æ¸…ç©º');
    } catch (error) {
      console.error(`æ¸…ç©ºæ•°æ®å¤±è´¥: ${error}`);
      throw new Error(error);
    }
  }
}

export const storage = StorageManager.getInstance();